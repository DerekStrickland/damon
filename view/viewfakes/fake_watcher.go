// Code generated by counterfeiter. DO NOT EDIT.
package viewfakes

import (
	"sync"

	"github.com/hashicorp/damon/models"
	"github.com/hashicorp/damon/view"
	"github.com/hashicorp/nomad/api"
)

type FakeWatcher struct {
	ForceUpdateStub        func()
	forceUpdateMutex       sync.RWMutex
	forceUpdateArgsForCall []struct {
	}
	SubscribeStub        func(api.Topic, func())
	subscribeMutex       sync.RWMutex
	subscribeArgsForCall []struct {
		arg1 api.Topic
		arg2 func()
	}
	SubscribeHandlerStub        func(models.Handler, func(string, ...interface{}))
	subscribeHandlerMutex       sync.RWMutex
	subscribeHandlerArgsForCall []struct {
		arg1 models.Handler
		arg2 func(string, ...interface{})
	}
	SubscribeToJobStatusStub        func(string, func()) error
	subscribeToJobStatusMutex       sync.RWMutex
	subscribeToJobStatusArgsForCall []struct {
		arg1 string
		arg2 func()
	}
	subscribeToJobStatusReturns struct {
		result1 error
	}
	subscribeToJobStatusReturnsOnCall map[int]struct {
		result1 error
	}
	SubscribeToLogsStub        func(string, string, func())
	subscribeToLogsMutex       sync.RWMutex
	subscribeToLogsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 func()
	}
	SubscribeToMetricsStub        func(func())
	subscribeToMetricsMutex       sync.RWMutex
	subscribeToMetricsArgsForCall []struct {
		arg1 func()
	}
	SubscribeToNamespacesStub        func(func())
	subscribeToNamespacesMutex       sync.RWMutex
	subscribeToNamespacesArgsForCall []struct {
		arg1 func()
	}
	SubscribeToTaskGroupsStub        func(string, func()) error
	subscribeToTaskGroupsMutex       sync.RWMutex
	subscribeToTaskGroupsArgsForCall []struct {
		arg1 string
		arg2 func()
	}
	subscribeToTaskGroupsReturns struct {
		result1 error
	}
	subscribeToTaskGroupsReturnsOnCall map[int]struct {
		result1 error
	}
	UnsubscribeStub        func()
	unsubscribeMutex       sync.RWMutex
	unsubscribeArgsForCall []struct {
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWatcher) ForceUpdate() {
	fake.forceUpdateMutex.Lock()
	fake.forceUpdateArgsForCall = append(fake.forceUpdateArgsForCall, struct {
	}{})
	stub := fake.ForceUpdateStub
	fake.recordInvocation("ForceUpdate", []interface{}{})
	fake.forceUpdateMutex.Unlock()
	if stub != nil {
		fake.ForceUpdateStub()
	}
}

func (fake *FakeWatcher) ForceUpdateCallCount() int {
	fake.forceUpdateMutex.RLock()
	defer fake.forceUpdateMutex.RUnlock()
	return len(fake.forceUpdateArgsForCall)
}

func (fake *FakeWatcher) ForceUpdateCalls(stub func()) {
	fake.forceUpdateMutex.Lock()
	defer fake.forceUpdateMutex.Unlock()
	fake.ForceUpdateStub = stub
}

func (fake *FakeWatcher) Subscribe(arg1 api.Topic, arg2 func()) {
	fake.subscribeMutex.Lock()
	fake.subscribeArgsForCall = append(fake.subscribeArgsForCall, struct {
		arg1 api.Topic
		arg2 func()
	}{arg1, arg2})
	stub := fake.SubscribeStub
	fake.recordInvocation("Subscribe", []interface{}{arg1, arg2})
	fake.subscribeMutex.Unlock()
	if stub != nil {
		fake.SubscribeStub(arg1, arg2)
	}
}

func (fake *FakeWatcher) SubscribeCallCount() int {
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	return len(fake.subscribeArgsForCall)
}

func (fake *FakeWatcher) SubscribeCalls(stub func(api.Topic, func())) {
	fake.subscribeMutex.Lock()
	defer fake.subscribeMutex.Unlock()
	fake.SubscribeStub = stub
}

func (fake *FakeWatcher) SubscribeArgsForCall(i int) (api.Topic, func()) {
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	argsForCall := fake.subscribeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWatcher) SubscribeHandler(arg1 models.Handler, arg2 func(string, ...interface{})) {
	fake.subscribeHandlerMutex.Lock()
	fake.subscribeHandlerArgsForCall = append(fake.subscribeHandlerArgsForCall, struct {
		arg1 models.Handler
		arg2 func(string, ...interface{})
	}{arg1, arg2})
	stub := fake.SubscribeHandlerStub
	fake.recordInvocation("SubscribeHandler", []interface{}{arg1, arg2})
	fake.subscribeHandlerMutex.Unlock()
	if stub != nil {
		fake.SubscribeHandlerStub(arg1, arg2)
	}
}

func (fake *FakeWatcher) SubscribeHandlerCallCount() int {
	fake.subscribeHandlerMutex.RLock()
	defer fake.subscribeHandlerMutex.RUnlock()
	return len(fake.subscribeHandlerArgsForCall)
}

func (fake *FakeWatcher) SubscribeHandlerCalls(stub func(models.Handler, func(string, ...interface{}))) {
	fake.subscribeHandlerMutex.Lock()
	defer fake.subscribeHandlerMutex.Unlock()
	fake.SubscribeHandlerStub = stub
}

func (fake *FakeWatcher) SubscribeHandlerArgsForCall(i int) (models.Handler, func(string, ...interface{})) {
	fake.subscribeHandlerMutex.RLock()
	defer fake.subscribeHandlerMutex.RUnlock()
	argsForCall := fake.subscribeHandlerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWatcher) SubscribeToJobStatus(arg1 string, arg2 func()) error {
	fake.subscribeToJobStatusMutex.Lock()
	ret, specificReturn := fake.subscribeToJobStatusReturnsOnCall[len(fake.subscribeToJobStatusArgsForCall)]
	fake.subscribeToJobStatusArgsForCall = append(fake.subscribeToJobStatusArgsForCall, struct {
		arg1 string
		arg2 func()
	}{arg1, arg2})
	stub := fake.SubscribeToJobStatusStub
	fakeReturns := fake.subscribeToJobStatusReturns
	fake.recordInvocation("SubscribeToJobStatus", []interface{}{arg1, arg2})
	fake.subscribeToJobStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWatcher) SubscribeToJobStatusCallCount() int {
	fake.subscribeToJobStatusMutex.RLock()
	defer fake.subscribeToJobStatusMutex.RUnlock()
	return len(fake.subscribeToJobStatusArgsForCall)
}

func (fake *FakeWatcher) SubscribeToJobStatusCalls(stub func(string, func()) error) {
	fake.subscribeToJobStatusMutex.Lock()
	defer fake.subscribeToJobStatusMutex.Unlock()
	fake.SubscribeToJobStatusStub = stub
}

func (fake *FakeWatcher) SubscribeToJobStatusArgsForCall(i int) (string, func()) {
	fake.subscribeToJobStatusMutex.RLock()
	defer fake.subscribeToJobStatusMutex.RUnlock()
	argsForCall := fake.subscribeToJobStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWatcher) SubscribeToJobStatusReturns(result1 error) {
	fake.subscribeToJobStatusMutex.Lock()
	defer fake.subscribeToJobStatusMutex.Unlock()
	fake.SubscribeToJobStatusStub = nil
	fake.subscribeToJobStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWatcher) SubscribeToJobStatusReturnsOnCall(i int, result1 error) {
	fake.subscribeToJobStatusMutex.Lock()
	defer fake.subscribeToJobStatusMutex.Unlock()
	fake.SubscribeToJobStatusStub = nil
	if fake.subscribeToJobStatusReturnsOnCall == nil {
		fake.subscribeToJobStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.subscribeToJobStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWatcher) SubscribeToLogs(arg1 string, arg2 string, arg3 func()) {
	fake.subscribeToLogsMutex.Lock()
	fake.subscribeToLogsArgsForCall = append(fake.subscribeToLogsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 func()
	}{arg1, arg2, arg3})
	stub := fake.SubscribeToLogsStub
	fake.recordInvocation("SubscribeToLogs", []interface{}{arg1, arg2, arg3})
	fake.subscribeToLogsMutex.Unlock()
	if stub != nil {
		fake.SubscribeToLogsStub(arg1, arg2, arg3)
	}
}

func (fake *FakeWatcher) SubscribeToLogsCallCount() int {
	fake.subscribeToLogsMutex.RLock()
	defer fake.subscribeToLogsMutex.RUnlock()
	return len(fake.subscribeToLogsArgsForCall)
}

func (fake *FakeWatcher) SubscribeToLogsCalls(stub func(string, string, func())) {
	fake.subscribeToLogsMutex.Lock()
	defer fake.subscribeToLogsMutex.Unlock()
	fake.SubscribeToLogsStub = stub
}

func (fake *FakeWatcher) SubscribeToLogsArgsForCall(i int) (string, string, func()) {
	fake.subscribeToLogsMutex.RLock()
	defer fake.subscribeToLogsMutex.RUnlock()
	argsForCall := fake.subscribeToLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWatcher) SubscribeToMetrics(arg1 func()) {
	fake.subscribeToMetricsMutex.Lock()
	fake.subscribeToMetricsArgsForCall = append(fake.subscribeToMetricsArgsForCall, struct {
		arg1 func()
	}{arg1})
	stub := fake.SubscribeToMetricsStub
	fake.recordInvocation("SubscribeToMetrics", []interface{}{arg1})
	fake.subscribeToMetricsMutex.Unlock()
	if stub != nil {
		fake.SubscribeToMetricsStub(arg1)
	}
}

func (fake *FakeWatcher) SubscribeToMetricsCallCount() int {
	fake.subscribeToMetricsMutex.RLock()
	defer fake.subscribeToMetricsMutex.RUnlock()
	return len(fake.subscribeToMetricsArgsForCall)
}

func (fake *FakeWatcher) SubscribeToMetricsCalls(stub func(func())) {
	fake.subscribeToMetricsMutex.Lock()
	defer fake.subscribeToMetricsMutex.Unlock()
	fake.SubscribeToMetricsStub = stub
}

func (fake *FakeWatcher) SubscribeToMetricsArgsForCall(i int) func() {
	fake.subscribeToMetricsMutex.RLock()
	defer fake.subscribeToMetricsMutex.RUnlock()
	argsForCall := fake.subscribeToMetricsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWatcher) SubscribeToNamespaces(arg1 func()) {
	fake.subscribeToNamespacesMutex.Lock()
	fake.subscribeToNamespacesArgsForCall = append(fake.subscribeToNamespacesArgsForCall, struct {
		arg1 func()
	}{arg1})
	stub := fake.SubscribeToNamespacesStub
	fake.recordInvocation("SubscribeToNamespaces", []interface{}{arg1})
	fake.subscribeToNamespacesMutex.Unlock()
	if stub != nil {
		fake.SubscribeToNamespacesStub(arg1)
	}
}

func (fake *FakeWatcher) SubscribeToNamespacesCallCount() int {
	fake.subscribeToNamespacesMutex.RLock()
	defer fake.subscribeToNamespacesMutex.RUnlock()
	return len(fake.subscribeToNamespacesArgsForCall)
}

func (fake *FakeWatcher) SubscribeToNamespacesCalls(stub func(func())) {
	fake.subscribeToNamespacesMutex.Lock()
	defer fake.subscribeToNamespacesMutex.Unlock()
	fake.SubscribeToNamespacesStub = stub
}

func (fake *FakeWatcher) SubscribeToNamespacesArgsForCall(i int) func() {
	fake.subscribeToNamespacesMutex.RLock()
	defer fake.subscribeToNamespacesMutex.RUnlock()
	argsForCall := fake.subscribeToNamespacesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWatcher) SubscribeToTaskGroups(arg1 string, arg2 func()) error {
	fake.subscribeToTaskGroupsMutex.Lock()
	ret, specificReturn := fake.subscribeToTaskGroupsReturnsOnCall[len(fake.subscribeToTaskGroupsArgsForCall)]
	fake.subscribeToTaskGroupsArgsForCall = append(fake.subscribeToTaskGroupsArgsForCall, struct {
		arg1 string
		arg2 func()
	}{arg1, arg2})
	stub := fake.SubscribeToTaskGroupsStub
	fakeReturns := fake.subscribeToTaskGroupsReturns
	fake.recordInvocation("SubscribeToTaskGroups", []interface{}{arg1, arg2})
	fake.subscribeToTaskGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWatcher) SubscribeToTaskGroupsCallCount() int {
	fake.subscribeToTaskGroupsMutex.RLock()
	defer fake.subscribeToTaskGroupsMutex.RUnlock()
	return len(fake.subscribeToTaskGroupsArgsForCall)
}

func (fake *FakeWatcher) SubscribeToTaskGroupsCalls(stub func(string, func()) error) {
	fake.subscribeToTaskGroupsMutex.Lock()
	defer fake.subscribeToTaskGroupsMutex.Unlock()
	fake.SubscribeToTaskGroupsStub = stub
}

func (fake *FakeWatcher) SubscribeToTaskGroupsArgsForCall(i int) (string, func()) {
	fake.subscribeToTaskGroupsMutex.RLock()
	defer fake.subscribeToTaskGroupsMutex.RUnlock()
	argsForCall := fake.subscribeToTaskGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWatcher) SubscribeToTaskGroupsReturns(result1 error) {
	fake.subscribeToTaskGroupsMutex.Lock()
	defer fake.subscribeToTaskGroupsMutex.Unlock()
	fake.SubscribeToTaskGroupsStub = nil
	fake.subscribeToTaskGroupsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWatcher) SubscribeToTaskGroupsReturnsOnCall(i int, result1 error) {
	fake.subscribeToTaskGroupsMutex.Lock()
	defer fake.subscribeToTaskGroupsMutex.Unlock()
	fake.SubscribeToTaskGroupsStub = nil
	if fake.subscribeToTaskGroupsReturnsOnCall == nil {
		fake.subscribeToTaskGroupsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.subscribeToTaskGroupsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWatcher) Unsubscribe() {
	fake.unsubscribeMutex.Lock()
	fake.unsubscribeArgsForCall = append(fake.unsubscribeArgsForCall, struct {
	}{})
	stub := fake.UnsubscribeStub
	fake.recordInvocation("Unsubscribe", []interface{}{})
	fake.unsubscribeMutex.Unlock()
	if stub != nil {
		fake.UnsubscribeStub()
	}
}

func (fake *FakeWatcher) UnsubscribeCallCount() int {
	fake.unsubscribeMutex.RLock()
	defer fake.unsubscribeMutex.RUnlock()
	return len(fake.unsubscribeArgsForCall)
}

func (fake *FakeWatcher) UnsubscribeCalls(stub func()) {
	fake.unsubscribeMutex.Lock()
	defer fake.unsubscribeMutex.Unlock()
	fake.UnsubscribeStub = stub
}

func (fake *FakeWatcher) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.forceUpdateMutex.RLock()
	defer fake.forceUpdateMutex.RUnlock()
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	fake.subscribeHandlerMutex.RLock()
	defer fake.subscribeHandlerMutex.RUnlock()
	fake.subscribeToJobStatusMutex.RLock()
	defer fake.subscribeToJobStatusMutex.RUnlock()
	fake.subscribeToLogsMutex.RLock()
	defer fake.subscribeToLogsMutex.RUnlock()
	fake.subscribeToMetricsMutex.RLock()
	defer fake.subscribeToMetricsMutex.RUnlock()
	fake.subscribeToNamespacesMutex.RLock()
	defer fake.subscribeToNamespacesMutex.RUnlock()
	fake.subscribeToTaskGroupsMutex.RLock()
	defer fake.subscribeToTaskGroupsMutex.RUnlock()
	fake.unsubscribeMutex.RLock()
	defer fake.unsubscribeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWatcher) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ view.Watcher = new(FakeWatcher)
